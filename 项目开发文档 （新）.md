**基于STM32F103RCT6的智能平衡小车项目软件开发文档**

**文档版本：** 2.0
**发布日期：** 2023-10-27
**项目经理：** [您的名字/团队成员名字]
**软件开发：** [团队成员名字]
**硬件开发：** [团队成员名字]
**测试工程师：** [团队成员名字]

---

### **1. 文档简介**

#### 1.1 项目概述
本项目旨在开发一款以高性能、低成本ARM Cortex-M3内核微控制器**STM32F103RCT6**为核心的**两轮自平衡小车**。小车集成**K210视觉识别模块**、**超声波测距模块**、**OLED显示屏**及**蓝牙通信模块**，构成一个功能完备的嵌入式移动机器人平台。项目目标为实现小车的**自主姿态平衡控制**，并在此基础上，融合多传感器信息，实现**远程遥控**、**视觉避障**、**超声波跟随**以及**脚本化自动动作**等高级功能，最终打造一个稳定、智能且可扩展的示范性系统。

#### 1.2 项目目标
*   **核心目标：** 基于STM32F103RCT6，实现小车在**最大负重4kg**条件下的稳定、快速自平衡，核心控制算法具备高鲁棒性。
*   **功能目标：**
    1.  通过**蓝牙模块**实现对小车的实时远程遥控（前进、后退、转向、停止）。
    2.  利用**K210视觉模块**进行前方障碍物识别，并实现自主避障行为。
    3.  利用**超声波模块**实现对小车的跟随功能。
    4.  设计并实现一套简单的**脚本解释器**，使小车能按预定义的脚本序列自动执行一系列动作。
    5.  通过**OLED显示屏**实时显示系统状态（如倾角、速度、模式、电池电压等）。
*   **技术目标：** 深入实践并掌握嵌入式实时系统设计、PID控制算法、传感器数据融合、机器视觉应用及多任务调度等关键技术。

#### 1.3 文档范围
本文档是本项目的权威技术参考，涵盖了从**软件需求规格**、**系统架构设计**、**模块详细设计**到**测试验证**的全流程。它定义了所有软件相关的功能、性能指标及接口规范，适用于所有项目开发、测试及管理人员。

#### 1.4 参考文献
*   STM32F103xx参考手册
*   MPU6050数据手册
*   Kendryte K210 官方文档
*   HC-SR04超声波模块数据手册
*   SSD1306 OLED显示屏数据手册
*   HC-05/HC-06蓝牙模块AT指令集

---

### **2. 总体描述**

#### 2.1 产品功能
本智能平衡小车系统是一个复杂的嵌入式系统，其核心功能建立在**姿态平衡控制系统**之上，并在此基础上扩展出多种智能行为模式。主要功能模块包括：

1.  **自动姿态控制系统：** 这是系统的基石。通过惯性测量单元实时采集车身姿态数据，在STM32中进行**传感器融合（如互补滤波）** 以解算出精确的俯仰角，并采用**PID控制算法**动态调整两个直流电机的输出力矩，使小车在各种扰动下维持动态平衡。

2.  **远程遥控系统：** 通过**蓝牙模块**与智能手机或电脑建立无线通信链路。用户可发送控制指令，系统解析后将其转换为小车的目标速度或转向指令，实现灵活的手动操控。

3.  **多模态感知与避障系统：**
    *   **视觉避障：** **K210视觉模块**作为"眼睛"，负责实时处理前方图像，通过训练好的模型或颜色跟踪算法识别障碍物。识别结果通过串口发送给主控STM32，主控据此规划路径，实现智能绕障。
    *   **超声波跟随：** **超声波模块**提供精确的距离信息。在此模式下，小车会自动与前方目标（如人）保持一个设定的安全距离，实现自动跟随功能。

4.  **脚本化任务系统：** 系统具备接收并解析简单脚本（通过直接烧录）的能力。脚本可以包含一系列动作指令（如"前进2秒"、"左转90度"、"等待"等），使小车能够自主完成复杂的预设任务序列。

5.  **人机交互系统：** **OLED显示屏**作为主要的信息输出界面，实时刷新显示系统的关键运行参数，如当前工作模式、车身倾角、电机PWM值、电池电量等。**通过转动轮胎切换显示模式和参数，通过KEY1按键进行选中确认**，极大方便了系统的调试与状态监控。

#### 2.2 用户特征
*   **最终用户：** 对智能机器人感兴趣的爱好者或演示人员，具备基本的移动设备操作能力。
*   **开发与维护人员：** 熟悉C/C++语言、STM32开发、嵌入式系统设计及控制理论的工程师或学生。

#### 2.3 设计与实现约束
*   **硬件平台：**
    *   主控MCU：**STM32F103RCT6**。
    *   关键传感器：MPU6050（IMU）、HC-SR04（超声波）、K210（视觉）。
    *   人机接口：0.96寸OLED显示屏（I2C）、蓝牙模块（UART）、按键KEY1。
    *   动力系统：带编码器的直流减速电机、TB6612FNG或L298N电机驱动。
    *   电源：锂电池组，需考虑电源管理，为整个系统提供稳定供电。
*   **软件平台：**
    *   语言：嵌入式C。
    *   库：标准外设库或HAL库。
    *   操作系统：考虑使用FreeRTOS以实现多任务并发管理。
*   **性能与物理约束：**
    *   系统需在**最大负载4kg**的条件下稳定运行。
    *   平衡控制环路频率不低于500Hz，以确保控制的实时性和稳定性。
    *   各功能模块间的通信需可靠，协议简洁。

---

### **3. 具体需求**

#### 3.1 功能需求

| 需求ID | 需求名称 | 需求描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| **FUN-001** | 系统初始化 | 上电后，系统能正确初始化所有外设（GPIO, UART, I2C, SPI, PWM, TIM），并完成传感器校准。 | 高 |
| **FUN-002** | 姿态数据采集 | 能以不低于200Hz的频率通过I2C读取MPU6050的加速度计和陀螺仪原始数据。 | 高 |
| **FUN-003** | 姿态解算 | 基于传感器原始数据，使用互补滤波或卡尔曼滤波算法，实时计算小车俯仰角（Pitch）。 | 高 |
| **FUN-004** | 平衡PID控制 | 以解算出的俯仰角作为反馈，使用位置式或增量式PID控制器，计算电机PWM输出，控制小车平衡。 | 高 |
| **FUN-005** | 电机驱动控制 | 根据PID输出和遥控速度指令，通过PWM和定时器编码器模式，精确控制两个直流电机的转速和方向。 | 高 |
| **FUN-006** | 视觉数据接收 | 通过串口（UART）接收来自OpenMV模块发送的障碍物信息（如：`OBSTACLE_LEFT`， `CLEAR`）。 | 中 |
| **FUN-007** | 自主避障决策 | 根据接收到的视觉信息，在自主模式下做出决策（如：遇到前方障碍物则停止，左侧有障碍物则右转）。 | 中 |
| **FUN-008** | 遥控指令接收 | 通过蓝牙串口接收来自手机APP的遥控指令（如：`F`：前进， `B`：后退， `L`：左转， `R`：右转， `S`：停止）。 | 中 |
| **FUN-009** | 工作模式切换 | 支持通过遥控指令或硬件按钮在"平衡模式"、"遥控模式"、"避障模式"之间切换。 | 中 |
| **FUN-010** | 系统状态反馈 | 能将系统关键状态（如：当前角度、电机PWM、工作模式）通过串口打印至上位机，便于调试。 | 低 |
| **FUN-011** | 超声波跟随 | 机器人利用前置超声波传感器实时测量与前方目标的距离，通过控制电机转速实现"目标跟随"。当目标移动时，机器人能够自动调整前进或后退速度，以保持与目标之间的预设距离。 | 中 |
| **FUN-012** | 动作规划功能 | 系统提供基本动作API（前进、后退、旋转等），可指定速度和时间参数，只要小车处于平衡状态即可执行规划动作。 | 高 |
| **FUN-013** | OLED菜单交互 | 通过转动轮胎切换OLED显示的模式和参数，通过KEY1按键进行选中确认。 | 中 |

#### 3.2 非功能需求

**性能需求：**

**平衡控制环路周期 ≤ 5ms。**

**遥控指令响应延迟 ≤ 100ms。**

**视觉数据处理延迟 ≤ 200ms。**

**可靠性：** 系统在意外扰动（如轻微碰撞）后，应在2秒内恢复平衡。

**可维护性：** 代码应模块化，注释清晰，易于参数调试和功能扩展。

**用户需求：**

**普通用户：通过网页端控制机器人运动与观察状态。**

**开发者/管理员：可配置参数、调试传感器、校准驱动模块。**

**界面需求：**

**Web控制界面包含：**

**控制区：方向键、速度调节滑块。**

**状态区：显示机器人速度、角度、加速度等。**

**图形显示区：实时折线图显示加速度曲线。**

**日志区：显示机器人运行状态与系统提示。**

**硬件与软件需求：**

| 类别 | 内容 |
| :--- | :--- |
| **硬件** | 单片机控制板、蓝牙模块、电机驱动板、超声波传感器、加速度传感器、电机与车体 |
| **软件** | Web控制前端（HTML、CSS、JavaScript）、后端接口（Node.js / Python Flask）、嵌入式底层程序（C / Arduino） |

---

### **4. 系统设计**

#### 4.1 系统架构（模块划分）
本系统采用**分层与模块化**的软件架构，并建议在**FreeRTOS实时操作系统**上运行，以实现多任务的并发执行与资源管理。系统自上而下分为以下四层：

*   **驱动层：** 为具体的外设提供初始化和基础读写操作，是软件与硬件的桥梁。
*   **算法层：** 封装核心控制与数据处理算法，为应用层提供纯净的计算服务。
*   **应用层：** 实现核心业务逻辑，通过多个独立的任务来组织功能，是系统的"大脑"。

**系统架构框图：**
```
+-----------------------------------------------+
|                 应用层                         |
|           (FreeRTOS Tasks)                    |
|  +---------+ +----------+ +----------------+  |
|  |Balance  | |Decision  | |Remote_Ctrl     |  |
|  |_Task    | |_Task     | |_Task           |  |
|  +---------+ +----------+ +----------------+  |
|  +---------+ +----------+ +----------------+  |
|  |Vision   | |Ultrasonic| |Action_Plan     |  |
|  |Comm_Task| |_Task     | |_Task           |    |
|  +---------+ +----------+ +----------------+    |
|  +---------+ +-------------------------------+  |
|  | Menu    |                                 |  |
|  |_Task    |                                 |  |
|  +---------+                                 |  |
+----------------------|------------------------+
                       |
+-----------------------------------------------+
|                 算法层                         |
|        (Pure C Algorithms)                    |
|  +------------------+ +---------------------+ |
|  |   姿态解算模块    | |    PID控制模块       | |
|  |  (IMU_Fusion)    | | (PID_Controller)    | |
|  +------------------+ +---------------------+ |
+----------------------|------------------------+
                       |
+-----------------------------------------------+
|                 驱动层                        |
|           (Device Drivers)                    |
|  +---------+ +----------+ +----------------+  |
|  |MPU6050  | |  Motor   | |   Bluetooth    |  |
|  |驱动     | |  驱动     | |    驱动        |  |
|  +---------+ +----------+ +----------------+  |
|  +---------+ +----------+ +----------------+  |
|  |K210通信 | |Ultrasonic| |     OLED       |  |
|  |驱动     | |   驱动   | |     驱动        |  |
|  +---------+ +----------+ +----------------+  |
|  +---------+                                  |
|  |  Key    |                                  |
|  | 驱动     |                                  |
|  +---------+                                  |
+----------------------|------------------------+
                       |
+-----------------------------------------------+
|              硬件抽象层 (HAL)                  |
|          (STM32 Peripherals)                  |
+-----------------------------------------------+
```

---

#### 4.2 软件模块详细设计

**驱动层模块 (Device Drivers)**

| 模块名称 | `mpu6050` (MPU6050驱动) |
| :--- | :--- |
| **定义** | 负责MPU6050传感器的底层初始化和数据读取。 |
| **功能** | 1. 初始化I2C和MPU6050芯片。<br>2. 读取加速度计和陀螺仪的六轴原始数据。<br>3. 读取传感器信息。 |
| **输入** | - I2C读写指令。 |
| **输出** | - `gyro`：陀螺仪数据数组，包含 x、y、z 轴数据；`accel`：加速度数据数组，包含 x、y、z 轴数据 |
| **接口定义** | `void IIC_MPU6050_Init(void);`<br>**功能：** MPU6050的IIC引脚初始化<br>**输入：** 无<br>**输出：** 无<br><br>`void MPU6050_initialize(void);`<br>**功能：** 初始化 MPU6050 以进入可用状态<br>**输入：** 无<br>**输出：** 无<br><br>`float* MPU6050_getDate(int way);`<br>**功能：** 读取 MPU6050 姿态信息（获取六轴数据）<br>**输入：** `way`：读取姿态信息的算法，根据不同的数值使用不同的算法返回姿态信息：`1.DMP 2.卡尔曼滤波 3.互补滤波`<br>**输出：** 返回值顺序: `Roll, Pitch, Yaw, gyro(x轴), gyro(y轴),gyro(z轴), accel(x轴),accel(y轴),accel(z轴)`<br><br>`int Read_Temperature(void);`<br>**功能：** 读取 MPU6050 内置温度传感器数据<br>**输入：** 无<br>**输出：** 摄氏温度 |
| **实现原理** | 通过STM32的HAL库I2C函数，按照MPU6050数据手册的寄存器地址，进行读写操作。 |
| **依赖关系** | 依赖硬件抽象层的 `I2C` 和 `GPIO`。 |

---

| 模块名称 | `motor` (电机驱动) |
| :--- | :--- |
| **定义** | 负责控制电机驱动芯片AT8236，管理电机的运动。 |
| **功能** | 1. 初始化PWM和编码器接口的定时器。<br>2. 设置电机的转速和方向（输出PWM）。<br>3. 读取编码器值，获取电机实际转速。 |
| **输入** | - 目标PWM值（带正负号，表示方向）。<br>- 编码器脉冲计数。 |
| **输出** | - 电机驱动芯片的PWM和方向控制信号。<br>- 计算出的电机转速值。 |
| **接口定义** | `void Balance_Motor_Init(void);`<br>**功能：** 初始化电机驱动相关外设<br>**输入：** 无<br>**输出：** 无<br><br>`void BalanceCar_PWM_Init(u16 arr,u16 psc);`<br>**功能：** 初始化PWM参数<br>**输入：** `arr：自动重装载值`<br>**输入：** `psc：预分频系数`<br>**输出：** 无<br><br>`void Encoder_Init_TIMX(void);`<br>**功能：** 初始化TIM3、TIM4定时器；X=3，4<br>**输入：** 无<br>**输出：** 无<br><br>`void Set_Pwm(int motor_left,int motor_right);`<br>**功能：** 给小车左右电机发送PWM信号，设置PWM值<br>**输入：** `motor_left`：左电机的PWM<br>**输入：** `motor_right`：右电机的PWM<br>**输出：** 无<br><br>`int Read_Encoder(Motor_ID MYTIMX);`<br>**功能：** 单位时间读取编码器计数<br>**输入：** `MYTIMX`：选择一个电机读取<br>**输出：** 编码器计数<br><br>`float* Get_Velocity_From_Encoder(int encoder_left, int encoder_right);`<br>**功能：** 返回左右轮的转速, 单位为mm/s<br>**输入：** `encoder_left`：左电机编码器值<br>**输入：** `encoder_right`：右电机编码器值<br>**输出：** `velocities`：一个速度数组 |
| **实现原理** | 通过通用定时器的TIM3、TIM4的编码接口模式，对电机的编码器信号进行计数。<br>通过高级定时器的TIM8的PWM输出功能，改变PWM信号的占空比，控制转速s和转向。 |
| **依赖关系** | 依赖硬件抽象层的 `TIM` (PWM和Encoder), `GPIO`。 |

---

| 模块名称 | `bluetooth` (蓝牙驱动) |
| :--- | :--- |
| **定义** | 负责蓝牙模块的初始化和数据收发。 |
| **功能** | 1. 初始化USART串口。<br>2. 手机通过内置蓝牙配对连接平衡车上的蓝牙模块。<br>3. 蓝牙模块接收平衡小车APP的数据并发送给开发板解析。 |
| **输入** | - 待发送的数据字节流。<br>- 串口接收到的原始字节流。 |
| **输出** | - 通过串口发送的数据。<br>- 接收到的原始数据（供上层解析）。 |
| **接口定义** | `void uart_init(u32 bound);`<br>**功能：** 初始化串口USART1<br>**输入：** `bound`：波特率 (常用: 9600/115200)<br>**输出：** 无<br><br>`void bluetooth_init(void);`<br>**功能：** 初始化蓝牙模块<br>**输入：** 无<br>**输出：** 无<br><br>`void USART1_Send_ArrayU8(uint8_t *BufferPtr, uint16_t Length);`<br>**功能：** 发送字符串<br>**输入：** `BufferPtr`：字符串指针<br>**输入：** `Length`：字符串长度<br>**输出：** 无<br><br>`void UART5_Send_ArrayU8(uint8_t *BufferPtr, uint16_t Length);`<br>**功能：** 发送字节数组<br>**输入：** `BufferPtr`：待发送的数据指针<br>**输入：** `Length`：数据长度<br>**输出：** 无<br><br>`void deal_bluetooth(uint8_t rxbuf);`<br>**功能：** 处理接收到的蓝牙数据<br>**输入：** `rxbuf`：接收到的数据<br>**输出：** 无<br><br>`void UART5_IRQHandler(void);`<br>**功能：** 串口中断服务<br>**输入：** 无<br>**输出：** 无<br><br>`void Protocol(void);`<br>**功能：** 根据协议解析蓝牙模块数据<br>**输入：** 无<br>**输出：** 无 |
| **实现原理** | 配置STM32的USART外设，使用中断方式实现数据的异步收发。 |
| **依赖关系** | 依赖硬件抽象层的 `USART`。 |

---

| 模块名称 | `k210_comm` (K210通信驱动) |
| :--- | :--- |
| **定义** | 负责与K210视觉模块的串口通信。 |
| **功能** | 1. 初始化与K210通信的USART2串口。<br>2. 发送配置指令或请求数据给K210。<br>3. 接收K210发送的识别结果数据。 |
| **输入** | - 待发送给K210的指令或数据。 |
| **输出** | - 从K210接收到的原始数据流。 |
| **接口定义** | `void USART2_init(u32 baudrate);`<br>**功能：** 初始化 USART2（用于 K210 通信）<br>**输入：** `baudrate`：波特率<br>**输出：** 无<br><br>`void K210_Send_Msg(const char *data_str);`<br>**功能：** 向 K210 模块发送字符串消息<br>**输入：** `data_str`：待发送的字符串<br>**输出：** 无<br><br>`void USART2_Send_ArrayU8(uint8_t *BufferPtr, uint16_t Length);`<br>**功能：** 发送一个字节数组到 K210 模块<br>**输入：** `BufferPtr`：待发送的数据指针<br>**输入：** `Length`：数据长度<br>**输出：** 无<br><br>`char* K210_Deal_Recv(uint8_t recv_msg);`<br>**功能：** 解析 K210 模块发来的消息<br>**输入：** `recv_msg`：接收到的字符<br>**输出：** 接收的完整字符串 |
| **实现原理** | 开发板程序通过板载KEY按键控制串口2发送不同的数据；K210视觉模块的程序会解析开发板串口2发送的数据，根据数据控制K210视觉模块。 |
| **依赖关系** | 依赖硬件抽象层的 `USART`。 |

---

| 模块名称 | `ultrasonic` (超声波驱动) |
| :--- | :--- |
| **定义** | 负责超声波传感器的测距操作。 |
| **功能** | 1. 初始化超声波传感器。<br>2. 触发一次测距脉冲。<br>3. 测量Echo引脚高电平持续时间并计算距离。 |
| **输入** | - 无（主动触发）。 |
| **输出** | - 测量得到的距离值（单位：cm）。 |
| **接口定义** | `static void ultrasonic_init(void);`<br>**功能：** 初始化超声波传感器<br>**输入：** 无<br>**输出：** 无<br><br>`void TIM2_Cap_Init(u16 arr,u16 psc);`<br>**功能：** 定时器2通道2输入捕获初始化<br>**输入：** `arr`：自动重装值<br>**输入：** `psc`：时钟预分频数<br>**输出：** 无<br><br>`int get_distance(void);`<br>**功能：** 返回超声波传感器测得的距离，返回值单位为毫米 (mm) <br>**输入：** 无<br>**输出：** 距离<br><br>`void delay_ms(uint16_t n);`<br>**功能：** 延迟n毫秒<br>**输入：** `n`：延迟的时间（毫秒）<br>**输出：** 无 |
| **实现原理** | GPIO通用推挽输出功能触发超声波模块测距，定时器输入捕获获取超声波高电平时间，根据声速公式计算距离。 |
| **依赖关系** | 依赖硬件抽象层的 `GPIO` 和 `TIM`（用于输入捕获），依赖延迟函数delay_ms。 |

---

| 模块名称 | `oled` (OLED显示驱动) |
| :--- | :--- |
| **定义** | 负责0.91寸OLED显示屏的初始化和基本图形显示。 |
| **功能** | 1. 初始化OLED显示屏。<br>2. 实现画点、画线、清屏等基本绘图函数。<br>3. 显示字符串和数字。 |
| **输入** | - 待显示的字符串、数字或图形数据。 |
| **输出** | - 发送给OLED屏幕的控制指令和显示数据。 |
| **接口定义** | `void OLED_I2C_Init();`<br>**功能：** 初始化OLED显示屏<br>**输入：** 无<br>**输出：** 无<br><br>`void OLED_Clear(void);`<br>**功能：** 清空OLED屏幕<br>**输入：** 无<br>**输出：** 无<br><br>`void OLED_Draw_String(char *data, uint8_t x, uint8_t y, bool clear, bool refresh);`<br>**功能：** 在指定位置写入字符串<br>**输入：** `str`：想要OLED显示的字符串<br>**输入：** `x`：绘制字符串x方向上的起始坐标<br>**输入：** `y`：绘制字符串y方向上的起始坐标<br>**输入：** `clear`：是否清空屏幕<br>**输入：** `refresh`：是否立即刷新屏幕<br>**输出：** 无 <br><br>`void OLED_Refresh();`<br>**功能：** 刷新OLED显示，将显存内容更新到屏幕<br>**输入：** 无<br>**输出：** 无<br><br>`void SSD1306_GotoXY(uint16_t x, uint16_t y);`<br>**功能：** 设置下一个字符的绘制坐标<br>**输入：** `x`：x坐标<br>**输入：** `y`：y坐标<br>**输出：** 无<br><br>`void SSD1306_Putc(char ch, FontDef_t *Font, SSD1306_COLOR_t color);`<br>**功能：** 绘制单个字符<br>**输入：** `ch`：要绘制的字符<br>**输入：** `font`：使用的字体结构体<br>**输入：** `color`：字符颜色<br>**输出：** 无<br><br>`void SSD1306_DrawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, SSD1306_COLOR_t c);`<br>**功能：** 绘制一条线<br>**输入：** `x0`：起始点x坐标<br>**输入：** `y0`：起始点y坐标<br>**输入：** `x1`：结束点x坐标<br>**输入：** `y1`：结束点y坐标<br>**输入：** `c`：线条颜色<br>**输出：** 无 |
| **实现原理** | 通过I2C接口，按照数据手册的指令集，控制屏幕的显存，最终调用OLED_Refresh函数将显存内容更新到屏幕。 |
| **依赖关系** | 依赖硬件抽象层的 `I2C`。 |

---

| 模块名称 | `key` (按键驱动) |
| :--- | :--- |
| **定义** | 负责按键KEY1的初始化和状态读取。 |
| **功能** | 1. 初始化KEY1对应的GPIO引脚。<br>2. 读取KEY1的当前状态。<br>3. 实现外部中断。 |
| **输入** | - 无（主动读取）。 |
| **输出** | - 按键状态（按下或释放）。 |
| **接口定义** | `void Key1_GPIO_Init(void);`<br>**功能：** 初始化KEY1的GPIO<br>**输入：** 无<br>**输出：** 无<br><br>`uint8_t Key1_is_Press(void);`<br>**功能：** 判断按键是否被按下<br>**输入：** 无<br>**输出：** `KEY_PRESS`：按下；`KEY_RELEASE`：松开<br><br>`uint8_t Key1_State(uint8_t mode);`<br>**功能：** 读取按键K1的状态<br>**输入：** `mode`：设置模式，0：持续按下返回1；1：按下只返回一次1<br>**输出：** 按键状态<br><br>`uint8_t Key1_Long_Press(uint16_t timeout);`<br>**功能：** 读取按键K1的长按状态<br>**输入：** `timeout`：长按时间，单位为秒<br>**输出：** `1`：已达到长按状态，`0`：未达到<br><br>`void EXTI9_5_IRQHandler(void);`<br>**功能：** 提供按键中断服务<br>**输入：** 无<br>**输出：** 无 |
| **实现原理** | 配置GPIO为输入模式，通过按键触发外部中断，并根据触发的按键切换状态。 |
| **依赖关系** | 依赖硬件抽象层的 `GPIO`与`NVIC`。 |

---

**算法层模块 (Algorithms)**

| 模块名称 | `IMU_Fusion` (姿态解算模块) |
| :--- | :--- |
| **定义** | 对MPU6050的原始数据进行滤波和融合，解算得到稳定可靠的姿态角。 |
| **功能** | 1. 对加速度计和陀螺仪原始数据进行校准和单位转换。<br>2. 执行传感器融合算法，输出精确的俯仰角（Pitch）。 |
| **输入** | - MPU6050的原始三轴加速度和三轴陀螺仪数据（`int16_t`）。 |
| **输出** | - 融合后的姿态角（`float`，单位：度或弧度）。 |
| **接口定义** | `float* MPU6050_getDate(int way);`<br>**功能：** 使用互补滤波算法计算并返回小车姿态数据<br>**输入：** `way = 3`：使用互补滤波算法<br>**输出：** 返回值顺序: `Roll, Pitch, Yaw, gyro(x轴), gyro(y轴),gyro(z轴), accel(x轴),accel(y轴),accel(z轴)`<br><br>`float Complementary_Filter_x(float angle_m, float gyro_m);`<br>**功能：** 一阶互补滤波<br>**输入：** `angle_m`：加速度获取的角度<br>**输入：** `gyro_m`：加速度获取的角加速度<br>**输出：** x轴角速度<br><br>`float Complementary_Filter_y(float angle_m, float gyro_m);`<br>**功能：** 一阶互补滤波<br>**输入：** `angle_m`：加速度获取的角度<br>**输入：** `gyro_m`：加速度获取的角加速度<br>**输出：** y轴角速度 |
| **实现原理** | 实现互补滤波算法：angle = K1 * angle_m+ (1-K1) * (angle + gyro_m * dt)。加速度计的低频补偿可以有效地消除陀螺仪的积分误差，陀螺仪的高频滤波可以消除加速度计的波动，从而提高姿态估计的精确度和稳定性。 |
| **依赖关系** | 依赖 `mpu6050` 驱动层模块以获取原始数据。 |

---

| 模块名称 | `PID_Controller` (PID控制模块) |
| :--- | :--- |
| **定义** | 提供一个通用、可配置的PID控制器实现。 |
| **功能** | 1. 进行PID位置式或增量式计算。<br>2. 支持输出限幅和积分抗饱和。 |
| **输入** | - 目标值（`target`）<br>- 当前测量值（`encoder或position`）<br>- PID参数（Kp, Ki, Kd）。 |
| **输出** | - PID计算后的控制量输出（`pwm`）。 |
| **接口定义** | `int Position_PID (int position,int target);`<br>**功能：** 位置式PID控制器<br>**输入：** `position`：编码器测量位置信息<br>**输入：** `target`：目标位置<br>**输出：** 电机PWM（增量输出）<br><br>`int Incremental_PI (int Encoder,int Target);`<br>**功能：** 增量PID控制器<br>**输入：** `Encoder`：编码器测量值<br>**输入：** `target`：目标速度<br>**输出：** 电机PWM（增量输出） |
| **实现原理** | 实现位置式PID控制算法：`Uk = Kp * e(k) + Ki * ∑e(k) + Kd * [e(k) - e(k-1)]`。<br>实现增量式PID控制算法：`Δu(k)=K p​ ⋅(e(k)−e(k−1))+K i​ ⋅e(k)+K d​ ⋅(e(k)−2e(k−1)+e(k−2))` |
| **依赖关系** | 是一个纯算法模块，不依赖其他硬件模块。 |

---

**应用层模块 (Application Tasks)**

| 模块名称 | `Balance_Task` (平衡控制任务) |
| :--- | :--- |
| **定义** | 系统中优先级最高的核心任务，负责维持小车的直立平衡。 |
| **功能** |  1. 周期性调用姿态解算模块，获取精确的姿态角。<br>2. 调用平衡PID控制器，计算维持平衡所需的电机扭矩。<br>3. 综合遥控指令的速度前馈，调用电机驱动模块输出最终PWM。<br>4. 提供平衡状态检测，为动作规划模块提供基础。 |
| **输入** | - 来自`IMU_Fusion`的姿态角。<br>- 来自`Decision_Task`的目标速度指令。<br>- 来自`Action_Plan_Task`的规划动作速度指令。 |
| **输出** | - PWM控制信号（通过`motor`模块输出）。<br>- 系统平衡状态标志。 |
| **接口定义** | `int Balance_PD(float Angle,float Gyro);`<br>**功能：** 直立PD控制<br>**输入：** `Angle`：角度<br>**输入：** `Gyro`：角速度<br>**输出：** `balance`：直立控制PWM<br><br>`int Velocity_PI(int encoder_left,int encoder_right);`<br>**功能：** 速度控制PWM<br>**输入：** `encoder_left`：左轮编码器读数<br>**输入：** `encoder_right`：右轮编码器读数<br>**输出：** 速度控制PWM<br><br>`int Turn_PD(float gyro);`<br>**功能：** 转向控制<br>**输入：** Z轴陀螺仪<br>**输出：** 转向控制PWM |
| **实现原理** | 在FreeRTOS中创建一个高优先级任务，以固定短周期运行。读取当前姿态，通过PID运算，动态调整电机输出，形成一个高速闭环控制系统。 |
| **依赖关系** | 依赖 `IMU_Fusion`, `PID_Controller`, `motor`, `Decision_Task`, `Action_Plan_Task`。 |

---

| 模块名称 | `Action_Plan_Task` (动作规划任务) |
| :--- | :--- |
| **定义** | 负责执行预设的动作序列，实现小车的规划运动。 |
| **功能** | 1. 解析和执行预烧录的动作脚本序列。<br>2. 提供基本动作API：前进、后退、旋转等。<br>3. 控制动作的持续时间、速度和转向角度。<br>4. 依赖小车平衡状态，只有在平衡状态下才执行动作。 |
| **输入** | - 系统平衡状态标志（来自`Balance_Task`）。<br>- 预定义的动作脚本。 |
| **输出** | - 规划动作的速度指令（发送给`Balance_Task`）。 |
| **接口定义** | `void Action_Plan_Task(void *pvParameters);`<br>**功能：** 动作规划任务主函数（FreeRTOS任务）<br>**输入：** `pvParameters` - 任务参数<br>**输出：** 无<br><br>`void Action_MoveForward(int16_t speed, uint32_t duration_ms);`<br>**功能：** 执行前进动作<br>**输入：** `speed` - 前进速度（0-1000）<br>**输入：** `duration_ms` - 动作持续时间（毫秒）<br>**输出：** 无<br><br>`void Action_MoveBackward(int16_t speed, uint32_t duration_ms);`<br>**功能：** 执行后退动作<br>**输入：** `speed` - 后退速度（0-1000）<br>**输入：** `duration_ms` - 动作持续时间（毫秒）<br>**输出：** 无<br><br>`void Action_TurnLeft(int16_t angular_speed, uint32_t duration_ms);`<br>**功能：** 执行左转动作<br>**输入：** `angular_speed` - 角速度（0-1000）<br>**输入：** `duration_ms` - 动作持续时间（毫秒）<br>**输出：** 无<br><br>`void Action_TurnRight(int16_t angular_speed, uint32_t duration_ms);`<br>**功能：** 执行右转动作<br>**输入：** `angular_speed` - 角速度（0-1000）<br>**输入：** `duration_ms` - 动作持续时间（毫秒）<br>**输出：** 无<br><br>`void Action_Stop(void);`<br>**功能：** 停止当前动作<br>**输入：** 无<br>**输出：** 无<br><br>`void Action_ExecuteScript(const ActionScript *script);`<br>**功能：** 执行预定义的动作脚本<br>**输入：** `script` - 动作脚本指针<br>**输出：** 无 |
| **实现原理** | 一个中优先级的FreeRTOS任务，维护一个动作队列。当接收到动作指令时，检查小车平衡状态，只有在平衡状态下才执行动作。每个动作通过调用`Balance_SetVelocity`设置目标速度，使用FreeRTOS的`vTaskDelay`控制动作持续时间。 |
| **依赖关系** | 依赖 `Balance_Task`（设置速度和获取平衡状态）。 |

---

| 模块名称 | `Decision_Task` (行为决策任务) |
| :--- | :--- |
| **定义** | 系统的"大脑"，负责融合多路输入信号，并决策出最终的运动指令。 |
| **功能** | 1. 接收并解析来自`Remote_Ctrl_Task`的遥控指令。<br>2. 接收来自`Vision_Comm_Task`的视觉避障指令和`Ultrasonic_Task`的跟随指令。<br>3. 根据当前工作模式，仲裁并输出最终的目标速度/转向指令。<br>4. 调用`Action_Plan_Task`中的动作函数实现复杂行为。 |
| **输入** | - 遥控指令、视觉指令、超声波距离数据、系统模式标志。 |
| **输出** | - 最终的目标速度（左轮、右轮）指令，发送给`Balance_Task`。<br>- 对`Action_Plan_Task`的动作函数调用。 |
| **接口定义** | `void Decision_Task(void *pvParameters);`<br>**功能：** 行为决策任务主函数（FreeRTOS任务）<br>**输入：** `pvParameters` - 任务参数<br>**输出：** 无<br><br>`void Decision_SetTargetVelocity(int16_t left, int16_t right);`<br>**功能：** 设置直接速度控制指令<br>**输入：** `left` - 左轮目标速度<br>**输入：** `right` - 右轮目标速度<br>**输出：** 无<br><br>`void Decision_SwitchMode(SystemMode new_mode);`<br>**功能：** 切换系统工作模式<br>**输入：** `new_mode` - 新的系统模式<br>**输出：** 无 |
| **实现原理** | 作为一个中优先级的FreeRTOS任务运行。它维护一个状态机，根据当前模式选择指令来源。在需要执行复杂动作时，调用`Action_Plan_Task`提供的动作函数。 |
| **依赖关系** | 依赖 `Remote_Ctrl_Task`, `Vision_Comm_Task`, `Ultrasonic_Task`，并为 `Balance_Task` 提供服务，调用 `Action_Plan_Task` 的动作函数。 |

---

| 模块名称 | `Menu_Task` (菜单任务) |
| :--- | :--- |
| **定义** | 负责OLED显示界面和用户交互处理。 |
| **功能** | 1. 管理OLED显示内容和界面布局。<br>2. 通过编码器值（轮胎转动）切换显示模式和参数。<br>3. 通过KEY1按键进行选中确认操作。<br>4. 显示系统状态、传感器数据、动作规划状态等信息。 |
| **输入** | - 编码器计数值（来自`motor`模块）。<br>- 按键状态（来自`key`模块）。<br>- 各模块的系统状态数据。 |
| **输出** | - OLED显示内容。<br>- 模式切换指令和参数设置。 |
| **接口定义** | `void Menu_Task(void *pvParameters);`<br>**功能：** 菜单任务主函数（FreeRTOS任务）<br>**输入：** `pvParameters` - 任务参数<br>**输出：** 无<br><br>`void Menu_UpdateDisplay(void);`<br>**功能：** 更新OLED显示内容<br>**输入：** 无<br>**输出：** 无<br><br>`MenuState Menu_GetCurrentState(void);`<br>**功能：** 获取当前菜单状态<br>**输入：** 无<br>**输出：** 当前菜单状态<br><br>`void Menu_ProcessEncoder(int32_t encoder_delta);`<br>**功能：** 处理编码器变化（轮胎转动）<br>**输入：** `encoder_delta` - 编码器变化量<br>**输出：** 无<br><br>`void Menu_ProcessKeyPress(Key_ID key);`<br>**功能：** 处理按键事件<br>**输入：** `key` - 按键标识<br>**输出：** 无 |
| **实现原理** | 一个低优先级的FreeRTOS任务，以固定周期运行。维护一个菜单状态机，根据编码器变化切换菜单项，根据按键事件执行选中操作。通过读取各模块的状态数据，组织显示内容。 |
| **依赖关系** | 依赖 `oled` 驱动层模块，`motor` 模块（获取编码器），`key` 模块（获取按键），需要从各应用层模块读取状态数据。 |

---

*(其他模块保持不变)*

| 模块名称 | `Remote_Ctrl_Task` (远程通信任务) |
| :--- | :--- |
| **定义** | 负责与手机APP/上位机进行蓝牙通信，接收控制指令和发送状态数据。 |
| **功能** | 1. 从蓝牙串口接收数据帧。<br>2. 解析协议，将原始数据转换为内部控制指令。<br>3. 将系统状态数据打包，通过蓝牙发送回上位机。 |
| **输入** | - 蓝牙串口接收到的原始字节流。<br>- 需要发送的系统状态数据。 |
| **输出** | - 解析后的标准化遥控指令（发送给`Decision_Task`）。<br>- 发送给上位机的数据包。 |
| **接口定义** | `void Remote_Ctrl_Task(void *pvParameters);`<br>**功能：** 远程通信任务主函数（FreeRTOS任务）<br>**输入：** `pvParameters` - 任务参数<br>**输出：** 无<br><br>`void Remote_SendStatus(float angle, uint8_t mode, uint16_t battery);`<br>**功能：** 发送系统状态数据<br>**输入：** `angle` - 当前俯仰角<br>**输入：** `mode` - 系统工作模式<br>**输入：** `battery` - 电池电压<br>**输出：** 无 |
| **实现原理** | 一个中低优先级的FreeRTOS任务，循环检查串口接收缓冲区。使用一个简单的协议解析器来确保数据的完整性。 |
| **依赖关系** | 依赖 `bluetooth` 驱动层模块。与 `Decision_Task` 和 `Menu_Task` 有数据交互。 |

---

| 模块名称 | `Vision_Comm_Task` (视觉通信任务) |
| :--- | :--- |
| **定义** | 负责与K210视觉模块进行串口通信，接收识别结果。 |
| **功能** | 1. 从K210串口接收数据帧。<br>2. 解析预设的视觉协议。<br>3. 将解析出的障碍物方位或手势识别结果发送给`Decision_Task`。 |
| **输入** | - K210串口发送来的原始字节流。 |
| **输出** | - 解析后的视觉指令（如枚举类型：`VISION_OBSTACLE_LEFT`）。 |
| **接口定义** | `void Vision_Comm_Task(void *pvParameters);`<br>**功能：** 视觉通信任务主函数（FreeRTOS任务）<br>**输入：** `pvParameters` - 任务参数<br>**输出：** 无<br><br>`VisionResult Vision_GetLatestResult(void);`<br>**功能：** 获取最新的视觉识别结果<br>**输入：** 无<br>**输出：** 视觉识别结果结构体 |
| **实现原理** | 与`Remote_Ctrl_Task`类似，是一个独立的任务，负责解析与K210约定的通信协议，将结果通过队列或全局变量传递给决策层。 |
| **依赖关系** | 依赖 `k210_comm` 驱动层模块。为 `Decision_Task` 提供服务。 |

---

| 模块名称 | `Ultrasonic_Task` (超声波任务) |
| :--- | :--- |
| **定义** | 负责周期性地触发超声波测距并处理距离数据。 |
| **功能** | 1. 控制超声波模块发起一次测距，读取并滤波返回的距离值。<br>2. 依靠超声波驱动的避障和跟随。<br>3. 在跟随模式下，根据距离值计算所需的速度指令。 |
| **输入** | - 超声波模块返回的高电平脉冲宽度。 |
| **输出** | - 处理后的距离值（单位：mm）。<br>- 在跟随模式下，输出目标速度指令给`Decision_Task`。 |
| **接口定义** | `void Ultrasonic_Task(void *pvParameters);`<br>**功能：** 超声波任务主函数（FreeRTOS任务）<br>**输入：** `pvParameters` - 任务参数<br>**输出：** 无<br><br>`int get_distance(void);`<br>**功能：** 获取超声波距离值<br>**输入：** 无<br>**输出：** 距离值（单位：毫米）<br><br>`void APP_avoid(void);`<br>**功能：** 根据超声波检测的距离控制小车运动方向<br>**输入：** 无<br>**输出：** 无<br><br>`void App_Change_Car(void);`<br>**功能：** 根据超声波距离控制小车实现避障和跟随动作<br>**输入：** 无<br>**输出：** 无 |
| **实现原理** | 一个固定周期运行的任务。通过GPIO触发测距，然后捕获输入脉冲。使用一个PID控制器，将测量距离与预设跟随距离比较，计算出跟随速度，实现超声波跟随和避障。 |
| **依赖关系** | 依赖 `ultrasonic` 驱动层模块。与 `Decision_Task` 有紧密的数据交互。 |

---

### **5. 开发计划与流程**

#### 5.1 开发流程
采用**迭代开发**模式，分阶段完成核心功能。
1.  **迭代一（基础平衡）：** 实现姿态感知和直立平衡。
2.  **迭代二（运动控制）：** 加入编码器，实现速度闭环和基本遥控。
3.  **迭代三（智能避障）：** 集成视觉模块，实现自主避障逻辑。
4.  **迭代四（动作规划）：** 实现动作规划功能和菜单交互系统。
5.  **迭代五（优化整合）：** 完善模式切换，优化性能，进行系统联调。

#### 5.2 版本控制
使用Git进行版本控制。仓库目录结构建议：
```
/Balance_Car
  ├── Docs/           # 存放本文档、原理图等
  ├── Firmware/       # STM32工程
  │   ├── Core/       # 核心业务逻辑（应用层）
  │   ├── Drivers/    # 驱动程序
  │   ├── Algorithms/ # 滤波、PID等算法
  │   └── Projects/   # IDE工程文件
  ├── Hardware/       # PCB设计文件
  └── Tools/          # 上位机、测试脚本等
```

---

### **6. 测试策略与计划**

#### 6.1 单元测试
*   **对象：** 各软件模块（如PID计算、滤波算法、协议解析）。
*   **方法：** 在PC上搭建测试环境，使用测试用例验证函数逻辑的正确性。

#### 6.2 集成测试
*   **阶段1：** 将姿态解算与PID控制集成，观察在给定模拟角度下PWM输出是否合理。
*   **阶段2：** 将电机控制集成，用手扶住小车，观察电机是否按预期方向抵抗倾斜。
*   **阶段3：** 集成遥控，测试指令是否能正确接收并影响小车运动。
*   **阶段4：** 集成动作规划，测试在平衡状态下动作函数是否能正确执行。
*   **阶段5：** 集成菜单系统，测试轮胎转动和按键是否能正常切换显示内容。

#### 6.3 系统测试
| 测试案例ID | 测试内容 | 预期结果 |
| :--- | :--- | :--- |
| **SYS-001** | 上电自检 | 所有模块初始化成功，LED闪烁。 |
| **SYS-002** | 平衡功能 | 小车在平地上能自主保持直立平衡。 |
| **SYS-003** | 抗扰动测试 | 轻推小车，它能迅速恢复平衡。 |
| **SYS-004** | 遥控功能 | 通过手机APP能控制小车前进、后退、转向。 |
| **SYS-005** | 避障功能 | 在避障模式下，小车能自动避开前方的障碍物。 |
| **SYS-006** | 模式切换 | 能通过指令在不同模式间平滑切换。 |
| **SYS-007** | 动作规划 | 在平衡状态下，能正确执行前进、后退、旋转等规划动作。 |
| **SYS-008** | 菜单交互 | 通过转动轮胎能切换OLED显示内容，通过KEY1按键能选中操作。 |

---

### **7. 附录**

*   **A. 通信协议格式定义**
    *   蓝牙遥控协议：`'F'` (前进)， `'B'` (后退) ...
    *   K210通信协议：`"OBSTACLE:LEFT\n"` (自定义)
*   **B. PID参数记录**
    *   平衡环Kp, Ki, Kd: [记录调试出的最佳参数]
    *   速度环Kp, Ki, Kd: [记录调试出的最佳参数]
*   **C. 动作脚本格式**
    *   预定义动作脚本结构：
    ```c
    typedef struct {
        ActionType type;
        int16_t speed;
        uint32_t duration_ms;
    } ActionStep;
    
    typedef struct {
        char name[20];
        ActionStep steps[MAX_SCRIPT_STEPS];
        uint8_t step_count;
    } ActionScript;
    ```